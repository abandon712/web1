<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<title>真实感史瓦西黑洞 v2.0 – 物理分层渲染</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;}
#tip{position:fixed;top:10px;left:10px;font:14px/18px sans-serif;color:#ccc;
     background:rgba(0,0,0,.45);padding:6px 10px;border-radius:4px; z-index: 100;}
#full{position:fixed;top:10px;right:10px;font:23px/23px sans-serif;color:#aaa;
      cursor:pointer;user-select:none; z-index: 100;}
</style>
</head>
<body>
<div id="tip">拖拽旋转 · 滚轮缩放 · GUI 调参 · 相机自动微旋</div>
<div id="full">⤢</div>

<!-- 1. Import Map: 模块化加载 -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
  }
}
</script>
<!-- dat.gui -->
<script src="https://unpkg.com/dat.gui@0.7.9/build/dat.gui.min.js"></script>

<!-- 2. 主脚本 -->
<script type="module">
// 3. 导入所有需要的 Three.js 组件
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';

// =================================================================
// 基础设置 (Scene, Camera, Renderer)
// =================================================================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 4, 13);

const renderer = new THREE.WebGLRenderer({
    antialias: true,
    powerPreference: "high-performance"
});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputEncoding = THREE.LinearEncoding;
document.body.appendChild(renderer.domElement);

// =================================================================
// 轨道控制器 (OrbitControls)
// =================================================================
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 4;
controls.maxDistance = 50;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.25;

scene.background = new THREE.Color(0x000000);

// =================================================================
// 全局 Uniforms
// =================================================================
const uni = {
    iTime:      { value: 0 },
    res:        { value: new THREE.Vector2(innerWidth, innerHeight) },
    camPos:     { value: new THREE.Vector3() },
    M:          { value: 1.0 },
    diskLum:    { value: 3.0 },
    noiseSpd:   { value: 0.2 },
    dopplerStr: { value: 0.95 },
};

// =================================================================
// 主着色器 (Fragment Shader) - 视觉核心
// =================================================================
const frag = `
precision highp float;

// ---------------- Uniforms ----------------
uniform float iTime, M, diskLum, noiseSpd, dopplerStr;
uniform vec2  res;
uniform vec3  camPos;

// ---------------- 常量定义 ----------------
#define PI 3.1415926535
#define MAX_STEPS 80          
#define MAX_DIST 100.0
#define RS (2.0 * M)         
#define ISCO_RADIUS (3.0 * RS) 
#define HIT_DIST (RS * 1.01)

// ---------------- 噪声函数 (FBM) ----------------
float hash(vec3 p){p=fract(p*0.3183099+0.1);p*=17.0;return fract(p.x*p.y*p.z*(p.x+p.y+p.z));}
float noise(vec3 p){vec3 i=floor(p),f=fract(p),u=f*f*(3.0-2.0*f);return mix(mix(mix(hash(i),hash(i+vec3(1,0,0)),u.x),mix(hash(i+vec3(0,1,0)),hash(i+vec3(1,1,0)),u.x),u.y),mix(mix(hash(i+vec3(0,0,1)),hash(i+vec3(1,0,1)),u.x),mix(hash(i+vec3(0,1,1)),hash(i+vec3(1,1,1)),u.x),u.y),u.z);}
float fbm(vec3 p,int octaves){float v=0.0,a=0.5;for(int i=0;i<octaves;i++){v+=a*noise(p);p*=2.0;a*=0.5;}return v;}

// ---------------- 程序化星空 ----------------
vec3 getStarfield(vec3 dir) {
    vec3 color = vec3(0.0);
    float stars = pow(fbm(dir * 350.0, 2), 20.0);
    color += vec3(stars * 0.9);
    float bright_stars = pow(fbm(dir * 50.0, 3), 25.0);
    color += vec3(bright_stars);
    return color;
}

// ---------------- 物理色彩映射 ----------------
vec3 colormap(float t) {
    t = pow(t, 1.8);
    vec3 red   = vec3(1.0, 0.2, 0.0);
    vec3 orange= vec3(1.0, 0.5, 0.0);
    vec3 white = vec3(1.0, 1.0, 0.9);
    return mix(red, orange, smoothstep(0.0, 0.35, t)) + 
           mix(vec3(0.0), white, smoothstep(0.35, 0.6, t)) * 1.5;
}

// ---------------- 吸积盘颜色计算 ----------------
vec3 getAccretionDiskColor(vec3 p, vec3 rd) {
    float r = length(p.xz);
    float outerRadius = RS * 7.5;
    
    float falloff = smoothstep(outerRadius, outerRadius - 2.0, r) * 
                    smoothstep(ISCO_RADIUS, ISCO_RADIUS + 0.5, r);
    if (falloff <= 0.0 || abs(p.y) > 0.1) return vec3(0.0);

    float temp_t = 1.0 - smoothstep(ISCO_RADIUS, outerRadius, r);
    vec3 baseColor = colormap(temp_t);
    
    float turbulence = fbm(vec3(r, p.y * 50.0, iTime * noiseSpd), 3);
    
    vec3 tangent = normalize(vec3(-p.z, 0.0, p.x));
    float doppler = 1.0 / (1.0 - dot(rd, tangent) * dopplerStr);
    float dopplerEffect = pow(doppler, 4.0);
    
    return baseColor * (0.7 + 0.3 * turbulence) * dopplerEffect * diskLum * falloff;
}

// ---------------- 物理核心: RK4 光线追踪 ----------------
// 此函数只负责计算光线路径，不计算颜色。
// 它通过 'bentDir' 输出最终方向，并返回是否落入黑洞。
bool traceGeodesic(vec3 ro, vec3 rd, out vec3 bentDir) {
    vec3 p = ro; vec3 v = rd; float dt = 0.1;
    for(int i = 0; i < MAX_STEPS; i++) {
        float r = length(p);
        if (r < HIT_DIST) return false; // 落入黑洞
        if (r > MAX_DIST) break;        // 逃逸
        
        vec3 accel = -1.5 * RS * p / (r*r*r);
        
        vec3 v1 = v + 0.5 * dt * accel;
        vec3 p1 = p + 0.5 * dt * v;
        float r1 = length(p1);
        vec3 accel1 = -1.5 * RS * p1 / (r1*r1*r1);

        vec3 v2 = v + 0.5 * dt * accel1;
        vec3 p2 = p + 0.5 * dt * v1;
        float r2 = length(p2);
        vec3 accel2 = -1.5 * RS * p2 / (r2*r2*r2);

        vec3 v3 = v + dt * accel2;
        vec3 p3 = p + dt * v2;
        float r3 = length(p3);
        vec3 accel3 = -1.5 * RS * p3 / (r3*r3*r3);

        p += dt/6.0 * (v + 2.0*v1 + 2.0*v2 + v3);
        v += dt/6.0 * (accel + 2.0*accel1 + 2.0*accel2 + accel3);
    }
    bentDir = normalize(v);
    return true; // 成功逃逸
}

// ---------------- 主函数 (Main) - 全新分层渲染逻辑 ----------------
void main() {
    // 1. 计算相机射线 (ro: 起点, rd: 初始方向)
    vec2 uv = (gl_FragCoord.xy * 2.0 - res.xy) / res.y;
    vec3 ro = camPos;
    vec3 ww = normalize(vec3(0.0) - ro);
    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));
    vec3 vv = cross(ww, uu);
    vec3 rd = normalize(uv.x * uu + uv.y * vv + ww * 2.0);

    // 2.【前景渲染】计算直线光线与吸积盘的交点
    vec3 foregroundColor = vec3(0.0);
    float t = -ro.y / rd.y;
    if (t > 0.0) {
        vec3 hitPoint = ro + rd * t;
        foregroundColor = getAccretionDiskColor(hitPoint, rd);
    }

    // 3.【背景渲染】进行完整的引力光线追踪
    vec3 backgroundColor = vec3(0.0);
    vec3 bentDir;
    bool escaped = traceGeodesic(ro, rd, bentDir);

    if (escaped) {
        // 光线逃逸，背景可能是星空或被引力透镜看到的盘的背面
        backgroundColor = getStarfield(bentDir);
        
        // 用弯曲后的光线，反向寻找它是否来自盘的背面
        float t_lensed = -ro.y / bentDir.y;
        if (t_lensed > 0.0) {
             vec3 hitPoint_lensed = ro + bentDir * t_lensed;
             // 累加来自背面的颜色
             backgroundColor += getAccretionDiskColor(hitPoint_lensed, bentDir);
        }

    } else {
        // 光线落入黑洞，背景就是纯黑色（黑洞阴影）
        backgroundColor = vec3(0.0);
    }
    
    // 4.【最终合成】
    // 如果前景有颜色，它将完全遮挡背景。否则，显示背景。
    // step(0.001, length(foregroundColor)) 会在前景颜色大于0时返回1，否则返回0。
    vec3 finalColor = mix(backgroundColor, foregroundColor, step(0.001, length(foregroundColor)));

    // 5.【光子环】这是一个独立的视觉层，叠加在所有东西之上
    float b = length(cross(ro, rd)); // 撞击参数
    float photonRingRadius = sqrt(27.0) * M; // 理论光子球半径 b_crit
    float ring = smoothstep(photonRingRadius + 0.15, photonRingRadius, b) - 
                 smoothstep(photonRingRadius, photonRingRadius - 0.15, b);
    finalColor += vec3(1.0, 0.8, 0.6) * ring * 2.0;

    gl_FragColor = vec4(finalColor, 1.0);
}`;


// =================================================================
// 创建承载 Shader 的平面网格
// =================================================================
const mat = new THREE.ShaderMaterial({
    fragmentShader: frag,
    vertexShader: `void main(){ gl_Position = vec4(position, 1.0); }`,
    uniforms: uni
});
const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
scene.add(quad);

// =================================================================
// 后期处理 (Post-Processing)
// =================================================================
const composer = new EffectComposer(renderer);
composer.setSize(innerWidth, innerHeight);

const renderPass = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    0.7,  // 辉光强度
    0.5,  // 辉光半径
    0.92  // 辉光阈值
);
const gammaShader = new ShaderPass(GammaCorrectionShader);

composer.addPass(renderPass);
composer.addPass(bloomPass);
composer.addPass(gammaShader);

// =================================================================
// GUI 控制面板 (dat.GUI)
// =================================================================
const gui = new dat.GUI();
const f1 = gui.addFolder('黑洞物理参数');
f1.add(uni.M, 'value', 0.5, 3, 0.05).name('质量 (M)');
f1.open();

const f2 = gui.addFolder('吸积盘视觉');
f2.add(uni.diskLum, 'value', 0, 8, 0.1).name('基础亮度');
f2.add(uni.noiseSpd, 'value', 0, 1, 0.01).name('湍流速度');
f2.add(uni.dopplerStr, 'value', 0.8, 1.0, 0.01).name('多普勒强度');
f2.open();

const f3 = gui.addFolder('后期与相机');
f3.add(bloomPass, 'strength', 0, 3, 0.1).name('辉光强度');
f3.add(bloomPass, 'radius', 0, 2, 0.05).name('辉光半径');
f3.add(bloomPass, 'threshold', 0, 1, 0.01).name('辉光阈值');
f3.add(controls, 'autoRotate').name('自动旋转');
f3.open();

// =================================================================
// 全屏与窗口大小调整
// =================================================================
document.getElementById('full').onclick = () => {
    document.fullscreenElement ? document.exitFullscreen() : document.body.requestFullscreen();
};
window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
    uni.res.value.set(innerWidth, innerHeight);
});

// =================================================================
// 渲染循环 (Animation Loop)
// =================================================================
const clock = new THREE.Clock();
function tick() {
    requestAnimationFrame(tick);
    const elapsedTime = clock.getElapsedTime();
    
    uni.iTime.value = elapsedTime;
    uni.camPos.value.copy(camera.position);
    
    controls.update();
    composer.render();
}
tick();

</script>
</body>
</html>
